<?php

require_once __DIR__ . '/../utils/jwt_handler.php'; // For get_bearer_token and validate_jwt
require_once __DIR__ . '/../models/User.php';       // For User::findById

/**
 * Authentication Middleware
 *
 * Verifies the JWT token from the Authorization header.
 * If valid, it sets a global or request-specific variable with user data.
 * If invalid or not present, it sends an appropriate HTTP error response and exits.
 *
 * @return array|null User data if authenticated, null otherwise (though script usually exits on failure).
 */
function require_auth(): ?array {
    $token = get_bearer_token();

    if (!$token) {
        http_response_code(401); // Unauthorized
        echo json_encode(['error' => 'Authorization token not found.']);
        exit;
    }

    $payload = validate_jwt($token);

    if (!$payload || !isset($payload['user_id'])) {
        http_response_code(401); // Unauthorized
        echo json_encode(['error' => 'Invalid or expired token.']);
        exit;
    }

    // Optionally, check if the user still exists in the database
    $user = User::findById((int)$payload['user_id']);
    if (!$user) {
        http_response_code(401); // Unauthorized
        echo json_encode(['error' => 'User associated with token not found.']);
        exit;
    }

    // You can augment the user data from the payload if needed,
    // but $user from DB is usually more up-to-date (excluding sensitive fields).
    // For simplicity, we'll return the user data fetched from DB.
    // Ensure password_hash is not included in $user if User::findById somehow returns it (it shouldn't by design).
    unset($user['password_hash']); // Defensive removal

    // Make user data available globally or return it
    // For this simple router, we can define a global or pass it around.
    // For now, just returning it is fine, controller can call this.

    // Define a global variable to hold the authenticated user's data for easy access in controllers.
    // This is a simple approach; more complex frameworks might use request objects or dependency injection.
    $GLOBALS['authenticated_user'] = $user;

    return $user;
}

/**
 * Retrieves the currently authenticated user data.
 * This should be called after require_auth() has successfully run.
 *
 * @return array|null The authenticated user's data, or null if not set.
 */
function get_current_user(): ?array {
    return $GLOBALS['authenticated_user'] ?? null;
}


// --- Example Usage (Conceptual - how it would be used in a route) ---
/*
// In your public/index.php or router, for a protected route:
// $request_path = ...;
// if ($request_path === '/api/protected/resource') {
//     $user = require_auth(); // This will exit if not authenticated
//     // If script continues, $user is authenticated
//     // $current_user_global = get_current_user(); // Alternative way to get user
//     echo json_encode(['message' => 'Welcome, ' . $user['email'] . '! This is a protected resource.']);
// }

// CLI Test (limited utility as it relies on $_SERVER variables not typically set in CLI)
if (php_sapi_name() === 'cli') {
    echo "Auth Middleware Test\n\n";

    // Simulate missing token
    echo "Test 1: Missing token\n";
    // In a real web request, require_auth() would exit. We can't fully simulate that here.
    // We'd need to mock $_SERVER['HTTP_AUTHORIZATION'] and then call it.
    // This CLI test is more for understanding the logic flow.

    // Simulate providing a token (you'd need a valid token generated by jwt_handler.php)
    // 1. Generate a token first (requires a user in DB)
    require_once __DIR__ . '/../models/User.php';
    $test_auth_email = "authuser_" . uniqid() . "@example.com";
    $test_auth_user_id = User::create($test_auth_email, "testpass");

    if ($test_auth_user_id) {
        echo "Created test user ID: " . $test_auth_user_id . "\n";
        $token = generate_jwt(['user_id' => $test_auth_user_id]);
        echo "Generated token: " . $token . "\n";

        $_SERVER['HTTP_AUTHORIZATION'] = "Bearer " . $token;
        echo "\nTest 2: Valid token\n";
        // In a real scenario, you'd call require_auth().
        // For CLI, we simulate the call and check what it might do.
        $validated_payload = validate_jwt($token); // Step 1 of require_auth
        if ($validated_payload && isset($validated_payload['user_id'])) {
            $user_from_db = User::findById((int)$validated_payload['user_id']); // Step 2
            if ($user_from_db) {
                $GLOBALS['authenticated_user'] = $user_from_db;
                echo "Simulated successful authentication for user: " . $user_from_db['email'] . "\n";
                print_r(get_current_user());
            } else {
                echo "Simulated auth failed: User from token not in DB.\n";
            }
        } else {
            echo "Simulated auth failed: Token validation failed.\n";
        }
        unset($_SERVER['HTTP_AUTHORIZATION']); // Clean up
        unset($GLOBALS['authenticated_user']);

    } else {
        echo "Could not create test user for AuthMiddleware CLI test.\n";
    }

    // Simulate invalid token
    $_SERVER['HTTP_AUTHORIZATION'] = "Bearer invalid.token.here";
    echo "\nTest 3: Invalid token\n";
    $invalid_payload = validate_jwt("invalid.token.here");
    if (!$invalid_payload) {
        echo "Simulated auth failed: Token validation failed (Correct for invalid token).\n";
    } else {
         echo "Simulated auth passed for invalid token (ERROR).\n";
    }
    unset($_SERVER['HTTP_AUTHORIZATION']);
}
*/
?>
